#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
This is the swarm_aws harness.  It runs a plugin and passes plugin parameters
to it:

    swarm cmd <options> <command>

where <options>     are the options for the 'cmd' plugin
      <command>     are the 'cmd' parameters.

The 'cmd' string determines which plugin is called.

An example:

    swarm cmd -i "ls -l /tmp"

This runs the command "ls -l /tmp" on all running instances.
The 'cmd' plugin gets the '-i' option.

There are two 'builtin' commands:
    help  displays this generic help
    list  lists all 'cmd' commands available
"""

import os
import sys
import glob
import getopt
import importlib
import traceback

import swarmcore
from swarmcore import log

log = log.Log('swarm.log', log.Log.DEBUG)


# program name and version
_Name = 'swarm'
_MajorRelease = 0
_MinorRelease = 1
__version__ = '%d.%d' % (_MajorRelease, _MinorRelease)


# default values
DefaultAuthDir = os.path.expanduser('~/.ssh')
DefaultPluginDir = 'plugins'


def list_commands(cmd_list):
    "Print available commands from a command list."""

    max_len = max([len(x[0]) for x in cmd_list])
    display_len = max_len + 2

    print('%s v%s' % (_Name, __version__))
    print('Recognized commands are:')
    for (name, version) in cmd_list:
        name = (name + ' '*30)[:display_len]
        print('    %s%s' % (name, version))

def get_plugin_info(plugin_dir=DefaultPluginDir):
    """Examine plugin dir for possible plugins.

    Returns a list containing the 'Plugin' dictionaries from each plugin
    module found.
    """

    # look at all *.py files in the plugon dir
    plugin_path = os.path.join(plugin_dir, '*.py')
    files = glob.glob(plugin_path)

    # look at each possible plugin file
    plugins = []
    for plugin_path in files:
        # first, get the import module name
        filename = os.path.basename(plugin_path)
        if filename.startswith('__'):
            continue        # ignore __init__.py, etc
        (mod_name, _) = os.path.splitext(filename)

        # try importing plugin
        # we simulate a "from plugins import <module> as plugin"
        try:
            plugin_module = __import__(plugin_dir, globals(), locals(), [mod_name], -1)
        except ImportError:
            continue
        plugin = getattr(plugin_module, mod_name)

        # get 'Plugin' attribute - the plugin data
        try:
            info = getattr(plugin, 'Plugin')
        except AttributeError:
            continue
        info['module'] = mod_name
        plugins.append(info)

    return plugins


def swarm(verbose, cmd_args):
    """Perform a swarm_aws command.

    verbose   True if we are to be verbose
    cmd_args  a list of args for the command (first is the command)
    """

    # if no args at all assume 'help' command
    if not cmd_args:
        cmd_args = ['help']

    # split off the command string
    command = cmd_args[0].lower()
    cmd_args = cmd_args[1:]

    # get plugin data, a list of tuples: (name, version)
    # also get a reference to the plugin dict for the command (plugin_data)
    plugin_info = get_plugin_info()
    plugin_data = []
    cmd_plugin = None
    for plugin in plugin_info:
        plugin_data.append((plugin['command'], plugin['version']))
        if plugin['command'] == command:
            cmd_plugin = plugin
    builtins_data = [('list', 'builtin'), ('help', 'builtin')]
    plugin_data.extend(builtins_data)
    plugin_data = sorted(plugin_data, key=lambda x: x[0])

    # handle a builtin command
    if command == 'list':
        # list acceptable commands and version
        list_commands(plugin_data)
        return 0
    elif command == 'help':
        usage()
        return 0

    if cmd_plugin is None:
        print("Command '%s' is not recognised." % command)
        list_commands(plugin_data)
        return 10

    # pass args to plugin code
    # we simulate a "from plugins import <module> as plugin"
    try:
        plugin_module = __import__('plugins', globals(), locals(), ['plugin'], -1)
    except ImportError:
        raise
    plugin_entry = eval('plugin_module.%s.%s' % (cmd_plugin['module'], cmd_plugin['entry']))
    def_args = {}
    return plugin_entry(cmd_args, def_args)

def error(msg):
    """Print error message and quit."""

    print(msg)
    sys.exit(1)


def warn(msg):
    """Print error message and continue."""

    log.warn(msg)
    print(msg)


def usage(msg=None):
    """Print help for the befuddled user."""

    if msg:
        print(msg+'\n')
    print('%s v%s' % (_Name, __version__))
    print(__doc__)        # module docstring used


# our own handler for uncaught exceptions
def excepthook(type, value, tb):
    msg = '\n' + '=' * 80
    msg += '\nUncaught exception:\n'
    msg += ''.join(traceback.format_exception(type, value, tb))
    msg += '=' * 80 + '\n'

    print msg
    log.critical(msg)
    sys.exit(1)

# plug our handler into the python system
sys.excepthook = excepthook

# parse 'swarm' options
# stop after first arg that doesn't start '-'
argv = sys.argv[1:]
for (i, arg) in enumerate(argv):
    if not arg.startswith('-'):
        cmd_args_ndx = i
        swarm_args = argv[:cmd_args_ndx]
        cmd_args = argv[cmd_args_ndx:]
        break
else:
    swarm_args = argv
    cmd_args = []

try:
    opts, args = getopt.getopt(swarm_args, 'hVv',
                                           ['help', 'version', 'verbose'])
except getopt.error, msg:
    usage()
    sys.exit(1)

verbose = False
for (opt, param) in opts:
    if opt in ['-h', '--help']:
        usage()
        sys.exit(0)
    elif opt in ['-V', '--version']:
        print('%s v%s' % (_Name, __version__))
        sys.exit(0)
    elif opt in ['-v', '--verbose']:
        log.bump_level()
        verbose = True

# call the handler code
sys.exit(swarm(verbose, cmd_args))
