#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
This is the swarm_aws harness.  It runs a plugin and passes plugin parameters
to it:

    swarm cmd <options> <command>

where <options>     are the options for the 'cmd' plugin
      <command>     are the 'cmd' parameters.

The 'cmd' string determines which plugin is called.

An example:

    swarm cmd -i "ls -l /tmp"

This runs the command "ls -l /tmp" on all running instances.
The 'cmd' plugin gets the '-i' option.

There are two 'builtin' commands:
    help  displays this generic help
    list  lists all 'cmd' commands available
"""

import os
import sys
import glob
import getopt
import importlib
import traceback

import swarmcore
from swarmcore import log

log = log.Log('swarm.log', log.Log.DEBUG)


# program name and version
_Name = 'swarm'
_MajorRelease = 0
_MinorRelease = 1
__version__ = '%d.%d' % (_MajorRelease, _MinorRelease)


# default values
DefaultAuthDir = os.path.expanduser('~/.ssh')
DefaultPluginDir = 'plugins'


def get_plugin_info(plugin_dir=DefaultPluginDir):
    """Examine plugin dir for possible plugins.

    Returns a list containing the 'Plugin' dictionaries from each plugin
    module found.
    """

    # look at all *.py files in the plugon dir
    plugin_path = os.path.join(plugin_dir, '*.py')
    files = glob.glob(plugin_path)

    # look at each possible plugin file
    plugins = []
    for plugin_path in files:
        # first, get the import module name
        filename = os.path.basename(plugin_path)
        if filename.startswith('__'):
            continue        # ignore __init__.py, etc
        (mod_name, _) = os.path.splitext(filename)

        # try importing plugin
        # we simulate a "from plugins import <module> as plugin"
        try:
            plugin_module = __import__(plugin_dir, globals(), locals(), [mod_name], -1)
        except ImportError:
            continue
        plugin = getattr(plugin_module, mod_name)

        # get 'Plugin' attribute - the plugin data
        try:
            info = getattr(plugin, 'Plugin')
        except AttributeError:
            continue
        info['module'] = mod_name
        plugins.append(info)

    return plugins


def swarm(verbose, cmd_args):
    """Perform a swarm_aws command.

    verbose   True if we are to be verbose
    cmd_args  a list of args for the command (first is the command)
    """

    # if no args at all assume 'help' command
    if not cmd_args:
        cmd_args = ['help']

    # split off the command string
    command = cmd_args[0].lower()
    cmd_args = cmd_args[1:]

    # get plugin data
    plugin_info = get_plugin_info()
    plugin_data = None
    for plugin in plugin_info:
        if plugin['command'] == command:
            plugin_data = plugin

    # handle any builtin command
    builtins = ['help', 'list']
    if command in builtins:
        if command == 'list':
            # list acceptable commands and version
            # build list: [(name, version}, ...]
            list_info = [('list', '(builtin)'), ('help', '(builtin)')]
            for plugin in plugin_info:
                list_info.append(('%s' % plugin['command'], 'v%s' % plugin['version']))
            list_info = sorted(list_info, key=lambda x: x[0])
            # get length of longest command
            max_len = max([len(x[0]) for x in list_info])
            display_len = max_len + 2
            print('Recognized commands are:')
            for (name, version) in list_info:
                name = (name + ' '*30)[:display_len]
                print('    %s%s' % (name, version))
            return 0
        elif command == 'help':
            usage()
            return 0
        else:
            print("Unhandled builtin command: '%s'" % command)
            return 10

    if plugin_data is None:
        print("Unrecognized swarm command: '%s'" % command)
        print('Recognized commands are:\n\t%s' % ('\n\t'.join(recognized_cmds)))
        return 10

    # pass args to plugin code
    # we simulate a "from plugins import <module> as plugin"
    try:
        plugin_module = __import__('plugins', globals(), locals(), ['plugin'], -1)
    except ImportError:
        raise
    plugin_entry = eval('plugin_module.%s.%s' % (plugin_data['module'], plugin_data['entry']))
    def_args = {}
    return plugin_entry(cmd_args, def_args)

def error(msg):
    """Print error message and quit."""

    print(msg)
    sys.exit(1)


def warn(msg):
    """Print error message and continue."""

    log.warn(msg)
    print(msg)


def usage(msg=None):
    """Print help for the befuddled user."""

    if msg:
        print(msg+'\n')
    print(__doc__)        # module docstring used


# our own handler for uncaught exceptions
def excepthook(type, value, tb):
    msg = '\n' + '=' * 80
    msg += '\nUncaught exception:\n'
    msg += ''.join(traceback.format_exception(type, value, tb))
    msg += '=' * 80 + '\n'

    print msg
    log.critical(msg)
    sys.exit(1)

# plug our handler into the python system
sys.excepthook = excepthook

# parse 'swarm' options
# stop after first arg that doesn't start '-'
argv = sys.argv[1:]
for (i, arg) in enumerate(argv):
    if not arg.startswith('-'):
        cmd_args_ndx = i
        swarm_args = argv[:cmd_args_ndx]
        cmd_args = argv[cmd_args_ndx:]
        break
else:
    swarm_args = argv
    cmd_args = []

try:
    opts, args = getopt.getopt(swarm_args, 'hVv',
                                           ['help', 'version', 'verbose'])
except getopt.error, msg:
    usage()
    sys.exit(1)

verbose = False
for (opt, param) in opts:
    if opt in ['-h', '--help']:
        usage()
        sys.exit(0)
    elif opt in ['-V', '--version']:
        print('%s v%s' % (_Name, __version__))
        sys.exit(0)
    elif opt in ['-v', '--verbose']:
        log.bump_level()
        verbose = True

# call the handler code
sys.exit(swarm(verbose, cmd_args))
